2 variables.py

# variable = container for a value. Behaves as the value that it contains

# first_name = "Dude" string
# last_name = "Bro"
# full_name = first_name +" " last_name

#human = False boolean
#print("Are you a human: " + str(human))
#print(human)
#print(type(human))

#height = 250.5 float
#print("Your height is: " + str(height)+"cm")
#print(type(height))

#age = 21 integer
#age = age + 1
#age += 1

#print ("Your age is: " + str(age))
#print(type(age))


#print("Hello "+full_name)

#print(type(name))
#print("Hello " +name)


3 multiple assignment.py
# multiple assignment = allows us to assign multiple variables at the same time in one line of code

#name = "Dude"
#age = 21
#attractive = True

#name, age, attractive = "Dude", 21, True

#print(name)
#print(age)
#print(attractive)

#Spongebob = 30
#Patrick = 30
#Sandy = 30
#Squidward = 30

Spongebob = Patrick = Sandy = Squidward = 30
print(Spongebob)
print(Patrick)
print(Sandy)
print(Squidward)

4 string methods.py
name = "Dude Bro"

#print(len(name))
#print(name.find("D"))
#print(name.capitalize())
#print(name.upper())
#print(name.lower())
#print(name.isdigit())
#print(name.isalpha())
#print(name.count("o"))
#print(name.replace("o","a"))
#print(name*3)

5 type cast.py
#type casting = convert the data type of a value to another data type

x = 1 #int
y = 2.0 #float
z = "3" #str

x = float(x)
y = int(y)
z = int(z)

#int(y)

print("x is " +str(x))
print("y is " +str(y))
print(z*3)

6 user input.py
name = input("what is your name?: ")
age = input ("How old are you?: ")
age = int(age) + 1
height = float(input("How tall are you?: "))

print("Hello " + name )
print("You are " + str(age)+ " years old")
print("You are " +str(height) + "cm tall")

7 math functions.py
import math

pi = 3.14
x = 1
y = 2
z = 3

# print(round(pi)) rounds
# print(math.ceil(pi)) rounds up
# print(math.floor(pi)) rounds down
# print(abs(pi)) absolute value
# print(pow(pi,2)) raise by power of
# print(math.sqrt(pi)) square root
# print(max(pi,x,y,z)) finds highest value
# print (min(pi,x,y,z)) finds lowest value

8 string slicing.py
# slicing =     create a substring by extracting elements from another string
#               indexing[] or slice()
#               [start:stop:step]

# name = "Bro Code"

# first_name = name[0:3] [0:3]
# last_name = name [4:] [4:end]
# funky_name = name[::2] [0:end:2]
# reversed_name = name[::-1] [0:end:-1]

# print(reversend_name)

website1 = "http://wikipedia.com"
website2 = "http://google.com"

slice = slice(7,-4)
print(website1[slice])

9 if statements.py
# if statement = a block of code that will execute if it's condition is true

age = int(input("How old are you?: "))

if age >= 18:
    print("You are an adult")
elif age == 100:
    print("You are a century old")
elif age < 0:
    print("You haven't been born yet")
else:
    print("You are a minor")

10 logical operators.py
temp = int(input("What is the temperature outside?: "))

if not(temp >= 0 and temp <= 30):
    print("the temperature is good today!")
    print("Go outside!")
elif not(temp < 0 or temp > 30):
    print("The temperature is bad today!")
    print("Stay inside!")

11 while loops.py
# while loop = a statement that will execute it's block of code,
#               as long as it's condition remains true

name = None

while not name == 0:
    name = input("Enter your name: ")

print("Hello "+name)

12 for loop.py
import time
# for loop = a statement that will execute it's block of code
#            for a limited amount of times
#
#            while loop = uinlimited
#            for loop = limited

# for i in range(10):
#    print(i+1)

# for i in range(50,100+1,2):
#    print(i)

# for i in "Bryant Logan":
#    print(i)

for seconds in range(10,0,-1):
    print(seconds)
    time.sleep(1)
print("Happy New Year!")

13 nested loops.py
# nested loops = The "inner loop" will finish all of it's iterations before
#                finishing one iteration of the "outer loop"

rows = int(input("How many rows?: "))
columns = int(input("How many columns?:" ))
symbol = input("Enter a symbol to use: ")

for i in range(rows):
    for j in range(columns):
        print(symbol, end="")
    print()

14 break continue pass.py
# Loop Control Statements = change a loop's execution from its normal sequence

# break = used to terminate the loop entirely
# continue - skips to the next iteration of the loop
# pass = does nothing, acts as a placeholder

#while True:
    #name = input("Enter your name: ")
    #if name != "":
        #break

#phone_number ="123-456-7890"

#for i in phone_number:
    #if i == "-":
        #continue
    #print(i,end="")

for i in range(1,20):
    if i == 13:
        pass
    else:
        print(i)

15 lists.py
# list = used to store multiple items in a single variable
# each item in a list is called an element


food = ["pizza", "hamburger", "hotdog","spaghetti", "pudding"]

food[0] = "sushi"

#food.append("ice cream")
#food.remove("hotdog")
#food.pop()
#food.insert(0,"cake")
#food.sort()
#food.clear()
for x in food:
    print(x)

16_2D lists.py
#2D lists = a list of lists

drinks = ["coffee", "soda", "tea"]
dinner = ["pizza", "hamburger", "hotdog"]
dessert = ["cake", "ice cream"]

food = [drinks, dinner, dessert]

print(food[0][1])

17 tuples.py
# tuple = collection which is ordered an unchangeable
#         used to group together related data

student =("Bryant",21,"male")

print(student.count("Bryant"))
student.index("male")
print(student.index("male"))

for x in student:
    print(x)

if "Bryant" in student:
    print("Bryant is here!")

18 sets.py
# set = collection which is unorderd, unindexed. No duplicate values

utensils = {"fork","spoon","knife","knife","knife"}
dishes = ["bowl", "plate", "cup","knife"]

#utensils.add("napkin")
#utensils.remove("fork")
#utensils.clear()
#utensils.update(dishes)
#dinner_table = utensils.union(dishes)

#print(utensils.difference(dishes))
print(utensils.intersection(dishes))
#for x in dinner_table:
#print(x)

19 dictionary.py
# dictionary = A changeable, unordered collection of unique key:value pairs
#              Fast because they use hashing, allow us to access a value quickly

capitals = {'USA':'Washington DC',
            'India':'New Dehli',
            'China':'Beijing',
            'Russia':'Moscow'}


capitals.update({'Germany':'Berlin'})
capitals.update({'USA':'Las Vegas'})
capitals.pop('China')
capitals.clear()
#print(capitals['Russia'])
#print(capitals.get('Germany'))
#print(capitals.keys())
#print(capitals.values())
#print(capitals.items())
for key,value in capitals.items():
    print(key,value)

20 index operator.py
# index operator [] = gives access to a sequence's element (str,list,tuples)

name = "bryant Logan"

#if(name[0] .islower()):
 #   name = name.capitalize()

first_name = name[0:6].upper()
last_name = name[7:].lower()
last_character = name[-1]
print(last_character)

21 functions.py
# function = a block of code which is executed only when it is called.

from unicodedata import name


def hello(first_name, last_name, age):
    print("hello, " +first_name +last_name)
    print("you are " +str(age) +" years old")
    print("have a nice day!")


hello("Bryant ","Logan", 21)

22 return statement.py
# return statement = functions send Python values/object back to the caller.
#                    These values/objects are known as the function's return value

number1 = input("What is number1?: ")
number2 = input("What is number2?: ")

def multiply(number1,number2):
    return number1 * number2

x = multiply(int(number1),int(number2))

print(x)

def multiply(number1,number2):
    return number1 * number2
x = multiply(6,8)

print(x)

23 keyword arguments.py
#keyword arguments = arguments preceeded by an identifier when we pass them to a fuction
#                    The order of the arguments doesn't matter, unlike positional arguments
#                    Python knows the names of the arguments that our funtion receives

def hello(first,middle,last):
    print("Hello, "+first +middle +last)

hello("Code","Dude","Bro")

24 nested function calls.py
# nested function calls = function calls inside other function calls
#                         innermost function calls are resolved first
#                         returned value is used as argument for the next outer function

#num = input("Enter a whole positive number: ")
#num = float(num)
#num = abs(num)
#num = round(num)
#print(num)

print(round(abs(float(input("Enter a whole positive number: ")))))

25 variable scope.py
# scope = The region that a variable is recognized
#         A variable is only available from inside the region it is created.
#         A global and locally scoped versions of a variable can be created

name = "Logan" #global scope = available inside & outside of functions

def display_name():
    name = "Bryant"    #local scope (available only inside this function)
    print(name)

display_name()
print(name)

#L = Local
#E = Enclosing
#G = Global
#B = Built-in

26 args.py
# *args = parameter that will pack all arguments into a tuple
#         useful so that a function can accept a varying amount of arguments

def add(*args):
    sum = 0
    stuff = list(stuff)
    stuff[0] = 0
    for i in stuff:
        sum += i
    return sum

print(add(1,2,3,4,5,6))

27 kwargs.py
#  **kwargs = parameter that will pack all arguments into a directory
#             useful so that a function can accept a varying amount of keyword arguments

def hello(**kwargs):
    #print("Hello " + kwargs['first'] + " " + kwargs['last'])
    print("Hello,",end=" ")
    for key,value in kwargs.items():
        print(value, end=" ")

hello(title="Mr.",first="Bryant",middle="Gunthrope",last="Logan")

28 string format.py
#str.format() = optional method that gives users
#               more control when displaying output

#animal = "cow"
#item = "moon"

#print("The "+animal+" jumped over the "+item)

#print("The {} jumped over the {}".format(animal,item))
#print("The {1} jumped over the {0}".format(animal,item)) #positional argument
#print("The {animal} jumped over the {item}".format(animal="cow",item="moon"))

#text = "The {} jumped over the {}"
#print(text.format(animal,item))

#name = "Bryant"

#print("Hello, my name is {}".format(name))
#print("Hello, my name is {:10}. Nice to meet you".format(name)) #10 spaces
#print("Hello, my name is {:<10}. Nice to meet you".format(name)) #left-alight
#print("Hello, my name is {:>10}. Nice to meet you".format(name)) #right-align
#print("Hello, my name is {:^10}. Nice to meet you".format(name)) #center-align

number = 1000

print("the number is {:,}".format(number)) #add comma to 1000th places
print("the number is {:b}".format(number)) #binary
print("the number is {:o}".format(number)) #octale
print("the number is {:X}".format(number)) #Hexadecimal
print("the number is {:e}".format(number)) #scientific notation

29 random numbers.py
# random numbers

import random

x = random.randint(1,6)
y = random.random()

myList = ['rock','paper','scissors']
z = random.choice(myList)

cards = [1,2,3,4,5,6,7,8,9,"J","Q","K","A"]

random.shuffle(cards)
print(cards)

30 exception handling.py
#exception = event detected during execution that interrupts the flow of a program

from concurrent.futures.process import _ResultItem

try:
    numerator = int(input("Enter a number to divide: "))
    denominator = int(input("Enter a number to divide by: "))
    result = numerator / denominator
except ZeroDivisionError as e:
    print(e)
    print("You can't divide by zero! idiot!")
except ValueError as e:
    print(e)
    print("Enter only numbers, please")
except Exception as e:
    print(e)
    print("something went wrong :(")
else:
    print(result)
finally:
    print("This will always execute")

31 file detection.py
import os

path = "C:\\Users\\bryan\\Desktop\\madlibs.py"

if os.path.exists(path):
    print("That location exists")
    if os.path.isfile(path):
        print("That is a file")
else:
    print("That location doesn't exist")

32 read a file.py
try:
    with open("C:\\Users\\bryan\\Desktop\\test.txt") as file:
        print(file.read())
except FileNotFoundError:
    print("That file was not found")

33 write a file.py
text = "Have a nice day! see ya"
with open('test.txt', 'a') as file:
    file.write(text)

34 copy a file.py
# copyfile() =  copies contents of a file
# Copy() =      copyfile() + permission mode + destination can be a directory
# copy2() =     copy() + copies metadata (file's creation and modification times)

import shutil

shutil.copyfile('test.txt','copy.txt') #src,dst

35 moving a file.py
import os

source = "C:\\Users\\bryan\\Desktop\\AWS\\AWS Certifications\\Solutions Architect Associate\\code\\test.txt"
destination = "C:\\Users\\bryan\\Desktop\\Photography"

try:
    if os.path.exists(destination):
        print("There is already a file there")
    else:
        os.replace(source,destination)
        print(source+" was moved")
except FileNotFoundError:
    print(source+" was not found")

36 delete a file.py
import os

path = "C:\\Users\\bryan\\Desktop\\AWS\\AWS Certifications\\Solutions Architect Associate\\code\\test.txt"

os.remove(path)

try:
    os.remove(path)
except FileNotFoundError:
    print("That file was not found")
except PermissionError:
    print("You do not have permission to delete that")

37 modules.py
# module = a file containing python code. May contain functions, classes, etc.
# used with module programming, which is to separate a program into parts

#import other file as nickname
#from module import hello,bye
#help(modules)

hello()
bye()

38 rockpaperscissors.py
import random

while True:
    choices = ["rock", "paper", "scissors"]

    computer = random.choice(choices)
    player = None

    while player not in choices:
        player = input("rock, paper, or scissors?: ").lower()

        if player == computer:
            print("computer: ",computer)
            print("player: ",player)
            print("It's a tie!")

        elif player == "rock":
            if computer == "paper":
                print("computer: ",computer)
                print("player: ",player)
                print("You lose!")
            if computer == "scissors":
                print("computer: ",computer)
                print("player: ",player)
                print("You win!")
        elif player == "scissors":
            if computer == "paper":
                print("computer: ",computer)
                print("player: ",player)
                print("You win!")
            if computer == "rock":
                print("computer: ",computer)
                print("player: ",player)
                print("You lose!")
        elif player == "paper":
            if computer == "scissors":
                print("computer: ",computer)
                print("player: ",player)
                print("You lose!")
            if computer == "rock":
                print("computer: ",computer)
                print("player: ",player)
                print("You win!")            
        play_again = input("Play again? (yes/no: ").lower()

    if play_again != "yes":
        break

print("bye")

38 rps.py
import random

def play():
    user = input("What's your choice? 'r' for rock, 'p' for paper, 's' for scissors\n")
    computer = random.choice(['r', 'p', 's'])

    if user == computer:
        return 'It\'s a tie'
    
    if is_win(user, computer):
        return 'You won'
   
    return 'You lost!'

def is_win(player, opponent):
    if (player == 'r' and opponent =='s') or (player == 's' and opponent == 'p') \
        or (player =='p' and opponent =='r'):
        return True

print(play())

39 quiz game.py
#--------------
def new_game():
    
    guesses = []
    correct_guesses = 0
    question_num = 1

    for key in questions:
        print("-----------")
        print(key)
        for i in options[question_num-1]:
            print(i)
        guess = input("Enter (A, B, C, or D): ")
        guess = guess.upper()
        guesses.append(guess)

        correct_guesses += check_answer(questions.get(key), guess)
        
        check_answer(questions.get(key),guess)

        question_num += 1
    
    display_score(correct_guesses, guesses)



#--------------
def check_answer(answer, guess):
    
    if answer == guess:
        print("Correct!!")
        return 1
    else:
        print("WRONG!!!")
        return 0

#--------------
def display_score(correct_guesses, guesses):
    print("-----------")
    print("RESULTS")
    print("-----------")
    
    print("Answers: ", end=" ")
    for i in questions:
        print(questions.get(i), end=" ")
    print()

    print("Guesses: ", end="")
    for i in guesses:
        print(i, end=" ")
    print()

    score = int((correct_guesses/len(questions)) * 100)
    print("Your score is: "+str(score)+"%")
#--------------
def play_again():
    response = input("Do you want to play again? (yes or no): ")
    response = response.upper()

    if response == "YES":
        return True
    else:
        return False
#--------------


questions = {
"When was the Declaration of Independence signed?: ": "A",
"How often do we have a lear year?: ": "B",
"Who sang the song 'Thriller'?: ": "C",
"When did man land on the moon?: ": "A"
}

options = [["A. 1776", "B. 1492", "C. 1849", "D. 1700"],
          ["A. Yearly", "B. Every 4 years", "C. Every other year", "D. Every 5 years"],
          ["A. Stevie Wonder", "B. The Jackson 5", "C. Michael Jackson", "D. The Backstreet Boys"],
          ["A. 1969", "B. 1959", "C. 2001", "D. 1929"]]

new_game()

while play_again():
    new_game()

print("Thanks for playing!")

40 OOPS.py
### In separate python file:
class Car:

    def __init__(self,make,model,year,color):
        self.make = make
        self.model = model
        self.year = year
        self.color = color


    def drive(self):
        print("This car is driving")

    def stop(self):
        print("This car is stopped")

### In working file: 
# import Car

car_1 = Car("Chevy","Corvette",2021,"blue")
car_2 = Car("Ford","Mustant",2022,"Red")

print(car_1.make)
print(car_1.model)
print(car_1.year)
print(car_1.color)

car_1.drive()
car_1.stop()

41 classvairables.py
class Car:

    wheels = 4 #class variable

    def __init__(self,make,model,year,color):
        self.make = make #instance variable
        self.model = model #instance variable
        self.year = year #instance variable
        self.color = color #instance variable

42 inheritance.py
class Animal:
    alive = True
    
    def eat(self):
        print("This animale is eating")
    
    def sleep(self):
        print("This animal is asleep")

class Rabbit(Animal):
    def run(self):
        print("This rabbit is running")

class Fish(Animal):
    def swim(self):
        print("This fish is swimming")

class Hawk(Animal):
    def fly(self):
        print("This hawk is flying")

rabbit = Rabbit()
fish = Fish()
hawk = Hawk()

rabbit.run()
fish.swim()
hawk.fly()

43 multilevel inheritance.py
#multi-level inheritance = when a derived(child) class inherits another derived (child) class

class Organism:
    
    alive = True

class Animal(Organism):

    def eat(self):
        print("This animal is eating")

class Dog(Animal):
    def bark(self):
        print("This dog is barking")

dog = Dog()
print(dog.alive)
dog.bark()
dog.eat()

44 multipleinheritance.py
# multiple inheritance = when a child class is derived from more than one parent class

class Prey:

    def flee(self):
        print("This animal flees")
    

class Predator:

    def hunt(self):
        print("This animal is hunting")

class Rabbit(Prey):
    pass

class Hawk(Predator):
    pass

class Fish(Prey,Predator):
    pass

rabbit = Rabbit()
hawk = Hawk()
fish = Fish()

#rabbit.flee()
#hawk.hunt()
#fish.flee()
#fish.hunt()

45 methodoverriding.py
class Animal:

    def eat(Self):
        print("This animal is eating")

class Rabbit(Animal):
    
    def eat(self):
        print("This rabbit is nibbling")



rabbit = Rabbit()
rabbit.eat()

46 methodchaining.py
# method chaining = used to call multiple method sequentially
                    #each call performs an action on the same object and returns Self


class Car:

    def turn_on(self):
        print("You start the engine")
        return self

    def drive(self):
        print("You drive the car")
        return self

    def brake(self):
        print("You step on the brakes")
        return self

    def turn_off(self):
        print("You turn off the car")
        return self

car = Car()

#car.turn_on().drive()

#car.brake().turn_off()

car.turn_on()\
    .drive()\
    .brake()\
    .turn_off()

47 superfunction.py
# super() = Function used to give access to the methods of a parent class.
#           Returns a temporary object of a parent class when used

class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

class Square(Rectangle):

    def __init__(self, length, width):
        super().__init__(length,width)

    def area(self):
        return self.length*self.width

class Cube(Rectangle):

    def __init__(self, length, width, height):
        super().__init__(length,width)
        self.height = height

    def volume(self):
        return self.length*self.width*self.height


square = Square(3, 3)
cube = Cube(3, 3, 3)

print(square.area())
print(cube.volume())

48 abstractclasses.py
# prevents a user from creating an object of that class
# + compels a user to override abstract methods in a child class

# abstract class = a class which contains one or more abstract methods
# abstract method = a method that has a declaration but does not have an implementation

from abc import ABC, abstractmethod

class Vehicle(ABC):
    
    @abstractmethod
    def go(self):
        pass

class Car(Vehicle):

    def go(self):
        print("You drive the car")

class Motorcycle(Vehicle):

    def go(self):
        print("You ride the motorcycle")

vehicle = Vehicle()
car = Car()
motorcycle = Motorcycle()

vehicle.go()
car.go()
motorcycle.go()

49 objects as arugments.py
class Car:

    color = None

class Motorcycle:

    color = None

def change_color(vehicle, color):

    vehicle.color = color


car_1 = Car()
car_2 = Car()
car_3 = Car()

bike_1 = Motorcycle()

change_color(car_1,"red")
change_color(car_2,"white")
change_color(car_3,"blue")
change_color(bike_1,"black")

print(car_1.color)
print(car_2.color)
print(car_3.color)
print(bike_1.color)

50 duck typing.py
# Duck Typing = concept where the class of an object is less important than the methods/attributes that class might have
#               class type is not checked if minimum methos/attributes are present
#               "If it walks like a duck, and it quacks like a duck, then it must be a duck"

class Duck:

    def walk(self):
        print("This duck is walking")

    def talk(self):
        print("This duck is quacking")

class Chicken:
    
    def talk(self):
        print("This chicken is clucking")

class Person:

    def catch(self, duck):
        duck.walk()
        duck.talk()
        print("You caught the critter!")

duck = Duck()
chicken = Chicken()
person = Person()

person.catch(chicken)

51 walrus operator.py
# walrus operato :=

# new to python 3.8
# assignment expression aka walrus operator
# assignes values to variables as part of a larger expression

# happy = True
# print(happy)

# print(happy := True)

#foods = list()
#while True:
#    food = input("What food do you like?: ")
#    if food == "quit":
#        break
#    foods.append(food)

foods = list()
while food := input("What food do you like?: ") != "quit":
    foods.append(food)


52 functions to variables.py
#def hello():
    #print("Hello")

#print(hello)

#hi = hello
#hello()
#hi()

say = print
say("Woah! I can't believe this works! :0")

53 higer order functions.py
# Higher Order Function =   a function that either:
#                           1. accepts a function as an argument OR
#                           2. returns a function
#                           (In python, functions are also treated as objects)

#def loud(text):
#    return text.upper()

#def quiet(text):
#    return text.lower()

#def hello(func):
#    text = func("Hello")
#    print(text)

# hello(quiet)
# hello(loud)

def divisor(x):  #higher order function
    def dividend(y):
        return y/x
    return dividend

divide = divisor(2)
print(divide(10))

54 lambda.py
# lamda functions =     funtion written in 1 line using lambda keyword
#                       accepts any number of arguments, but only has one expression
#                       (Think of it as a shortcut)
#                       (Useful if needed for a short period of time, throw-away)

# lambda parameters:expression

#def double(x):
#    return x * 2

#print(double(5))

from random import lognormvariate


double = lambda x:x * 2
multiply = lambda x, y: x * y
add = lambda x,y,z: x+y+z
full_name = lambda first_name, last_name: first_name+" "+last_name
age_check = lambda age:True if age >= 18 else False

print(age_check(16))

55 sort.py
# sort() method     = used with lists
# sort() function   = used with iterables

students = [("Squidward","F", 60),
            ("Sandy","A", 33),
            ("Patrick","D", 36),
            ("Spongebob","B",20),
            ("Mr.Krabs","C", 78)]

age = lambda ages:ages[2]
#students.sort(key=age,reverse=True)
sorted_students= sorted(students,key=age)
for i in sorted_students:
    print(i)

56 map.py
# map() =   applies a function to each item in an iterable (list, tuple, etc.)
#map(function,iterable)

store = [("shirt",20.00),
         ("pants",25.00),
         ("jacket",50.00),
         ("socks",10.00)]

#to_euros = lambda data: (data[0],data[1]*0.82)
to_dollars = lambda data: (data[0],data[1]/0.82)
#store_euros = list(map(to_euros, store))
store_dollars = list(map(to_dollars, store))

for i in store_dollars:
    print(i)

57 filter.py
# filter() = creates a collection of elements from an iterable for which a function returns
#
# filter(function, iterable)

friends = [("Rachel",19),
           ("Monica",18),
           ("Phoebe",17),
           ("Joey",16),
           ("Chandler",21),
           ("Ross",20)]

age = lambda data:data[1] >= 21

drinking_buddies = list(filter(age, friends))

for i in drinking_buddies:
    print (i)

58 reduce.py
# reduce() =    apply a function to an iterable and reduce it to a single cumulative value
#               performs function on first two elements and repeats process until 1 value remails
#
# reduce(function, iterable)

import functools
from unittest import result

#letters = ["H","E","L","L","O"]
#word = functools.reduce(lambda x,y,:x + y,letters)
#print(word)

factorial = [5,4,3,2,1]
result = functools.reduce(lambda x,y,:x * y,factorial)

print(result)

59 list comprehensions.py
# list comprehension =  a way to create a new list with less syntax
#                       can mimic certain lambda functions, easier to read
#                       list = [expression for item in iterable]
#                       list = [expression for item in iterable if conditional]
#                       list = [expression if/else for item in iterable]

#squares = [i * i for i in range(1,11)]
#print(squares)

students = [100,90,80,70,60,50,40,30,0]

#passed_students = list(filter(lambda x: x>= 60, students))
#print(passed_students)

#passed_students = [i for i in students if i >= 60]

passed_students = [i if i >= 60 else "FAILED" for i in students]
print(passed_students)

60 dictionary comprehension.py
# dictonary comprehension =     creat dictionaries using an expression
#                               can replace for loops and certain lambda functions
#
# dictionary = {key: expression for (key,value) in iterable}

#cities_in_F = {'New York': 32, 'Bostion': 75, 'Los Angeles':100, 'Chicago':50}

#cities_in_C = {key: round((value-32)*(5/9)) for (key, value) in cities_in_F.items()}
#print(cities_in_C)

#weather = {'New York': "snowing", 'Bostion': "sunny", 'Los Angeles':"sunny", 'Chicago':"cloudy"}
#sunny_weather = {key:value for (key,value) in weather.items() if value == "sunny"}
#print(sunny_weather)

#cities = {'New York': 32, 'Bostion': 75, 'Los Angeles':100, 'Chicago':50}
#desc_cities = {key: ("WARM" if value >= 40 else "COLD") for (key,value) in cities.items()}
#print(desc_cities)

def check_temp(value):
    if value >= 70:
        return "HOT"
    elif 69>= value >=40:
        return "WARM"
    else:
        return "COLD"    

cities = {'New York': 32, 'Bostion': 75, 'Los Angeles':100, 'Chicago':50}
desc_cities = {key: check_temp(value) for (key,value) in cities.items()}
print(desc_cities)

61 zip function.py
# zip(*iterables) =     aggregate elements from two or more iteables (list, tuples, sets, etc.)
#                       creates a zip object with paired elements stored in tuples for each element

usernames = ["dude", "bro", "mister"]
passwords = ("p@ssword", "abc123", "guest")
login_date = ["1/1/2021","1/2/2021","1/3/2021"]

users = zip(usernames,passwords,login_date)

for i in users:
    print(i)
    

#users = dict(zip(usernames,passwords))

#print(type(users))

#for key,value in users.items():
#    print(key+" : "+value)

62 if__name__ = main.py
# if __name__ == '__main__'
# 1. Module can be run as a standalone program
# 2. Modue can be imported and used by other modules

# Python interpreter sets "special variables", one of which is __name__
# Python will assign the __name__ variable a value of '__main__' if it's the initial module being run

print(__name__)

63 time module.py
import time

# print(time.ctime(0))    #convert a time expressed in seconds since epoch to a readable string
#                       epoch = when your coputer thinks time began (reference point)

# print(time.time())         # return current seconds sinc epoch

# print(time.ctime(time.time()))

# time_object = time.localtime()
# print(time_object)
# local_time = time.strftime("%B %d %Y %H:%M:%S", time_object)
# print(local_time)

# time_string = "20 April, 2020"
# time_object = time.strptime(time_string,"%d %B, %Y")
# print(time_object)

time_tuple = (2020, 4, 20, 4, 20, 0, 0, 0, 0)
time_string = time.asctime(time_tuple)
print(time_string)

64 threading.py
# thread =  a flow of execution. Like a separate order of instructions.
#           However each thread takes a turn running to achieve concurrency
#           GIL = Global Interpreter Lock,
#           allows only one thread to hold the control of the Python interpreter at any one time
# cpu bound = program/task spends most of its time waiting for internal events (CPU intenseive)
#               Use multiprocessing

# io bound = program/task spends most of its time waiting for external events (user input)
#            use multithreading

import threading
import time

def eat_breakfast():
    time.sleep(3)
    print("You eat breakfast")

def drink_coffee():
    time.sleep(4)
    print("You drank coffee")

def study():
    time.sleep(5)
    print("You finish studying")

x = threading.Thread(target=eat_breakfast, args =())
x.start()

y = threading.Thread(target=drink_coffee, args =())
y.start()

z = threading.Thread(target=study, args =())
z.start()

x.join()
y.join()
z.join()

#eat_breakfast()
#drink_coffee()
#study()


print(threading.active_count())
print(threading.enumerate())
print(time.perf_counter())

65 daemon threads.py
# daemon thread =   a thread that runs in the background, not important for program to run
#                   your program will not wait for daemon threads to complete before exiting
#                   non-daemon threads cannot normally be killed, stay alive until task is complete
#
#                   ex. background tasks, garbage collection, waiting for input, long running processes


import threading
import time

def timer():
    print()
    count = 0
    while True:
        time.sleep(1)
        count += 1
        print("logged in for: ",count, "seconds")

x = threading.Thread(target=timer, daemon=True)
x.start()

x.setDaemon(True)

answer = input("Do you with to exit")

66 multiprocessing.py
# multiprocessing =     running tasks in parallel on different cpu cores, bypasses GIL used for threading
#                       multiprocessing = better for cpu bound tasks (heavy cpu usage)
#                       multithreading = better for io bound tasks (waiting around)

from multiprocessing import process, cpu_count
from multiprocessing.dummy import Process
import time

def counter(num):
    count = 0
    while count < num:
        count += 1

def main():
    
    a = Process(target=counter, args=(250000000,))
    b = Process(target=counter, args=(250000000,))
    c = Process(target=counter, args=(250000000,))
    d = Process(target=counter, args=(250000000,))

    a.start()
    b.start()
    c.start()
    d.start()

    a.join()
    b.join()
    c.join()
    d.join()

    print("finished in:",time.perf_counter(), "seconds")

if __name__ == '__main__':
    main()

67 GUI windows.py
from tkinter import *

# widgets = GUI elements: buttons, textboxes, labels, images
# windows = serves as a container to hold or contain these widgets

window = Tk() #instantiate an instance of a window
window.geometry("420x420")
window.title("Bryant's First GUI program")

#icon = PhotoImage(file='coffee.jpg')
#window.iconphoto(True,icon)
window.config(background="black")

window.mainloop() #place window on computer screen, listen for events

68 labels.py
# label =   an area widget that holds text and/or an image within a window

from tkinter import *

window = Tk()

#photo = PhotoImage(file=' x.png')

label = Label(window,
            text="Hello World",
            font=('Arial', 40, 'bold'),
            fg='#00FF00',
            bg='black',
            relief=RAISED, #SUNKEN
            bd=10,
            padx=20,
            pady=20)
            #image=photo,
            # compound='bottom')

label.pack()
#label.place(x=100,y=100)

window.mainloop()

69 buttons.py
# button = you click it, then it does stuff

from tkinter import *

count = 0


def click():
    global count
    count+=1
    print(count)

window =Tk()

#photo = PhotoImage(file='file.png')
#image = photo, in Button 

button = Button(window,
                text='click me!',
                command =click,
                font=("comic sans",30),
                fg="#00FF00",
                bg="black",
                activeforeground="#00FF00",
                activebackground="black",
                state=ACTIVE) #DISABLED
button.pack()

window.mainloop()

70 entrybox.py
#entry widget = textbox that accepts a single line of user input

from tkinter import *

def submit():
    username= entry.get()
    print(username)
    entry.config(state=DISABLED)

def delete():
    entry.delete(0,END)

def backspace():
    entry.delete(len(entry.get())-1,END)

window = Tk()

entry = Entry(window,
            font=("Arial",50),
            fg="#00FF00",
            bg="black",
            show="*")
#entry.insert(0,'Spongebob') default text in text box

entry.pack(side=LEFT)

submit_button = Button(window,text="submit",command=submit)
submit_button.pack(side=RIGHT)

delete_button = Button(window,text="delete",command=delete)
delete_button.pack(side=RIGHT)

backspace_button = Button(window,text="backspace",command=backspace)
backspace_button.pack(side=RIGHT)

window.mainloop()






